{"name":"Wfs input generator","tagline":"API to generate input files for many different seismic waveform solvers","body":"## Waveform Solver Input File Generator\r\n\r\nSeismic waveform solvers are generally written in a high-performance language\r\nand are controlled with the help of carefully crafted input files. These input\r\nfiles are very solver dependent and have their own quirks. The present module\r\nattempts to create a generic input file generator that hides the actual input\r\nfiles' syntax and has a usable Python API.\r\n\r\nFrom a high-level point of view the solvers require three distinct types of\r\ninput: the sources, the receivers, and a detailed configuration of the solver\r\nwhich includes all the remaining parts like time-stepping, the domain setup,\r\nwhich type of simulation to perform, and many more.\r\n\r\nThe `wfs_input_generator` module is able to extract the list of sources (or\r\n        seimic events) and the list of receivers (or seismic stations) from\r\nvarious common formats that are readily available. It also helps with the\r\nsolver specific configuration, other then the input file formatting, by\r\ndividing the configuration values in a (hopefully) small set of required\r\nparameters and a larger list of optional ones with sensible default values.\r\nFurthermore it takes care of a lot of sanity, type, and availability checks\r\nwith the goal of producing only valid input files.\r\n\r\nA main focus of the development was to make it as easy as possible to add\r\nsupport for further waveform solver input file formats. This is achieved by\r\nemploying a system of simple backends; one for each supported solver.\r\n\r\nThe following sketch shows a short overview of the module's workings:\r\n\r\n![Flow](https://raw.github.com/krischer/wfs_input_generator/master/misc/wfs_input_gen_flow.png)\r\n\r\n\r\n## Navigation\r\n\r\n* [Dependencies and Installation](#dependencies-and-installation)\r\n    * [Requirements](#requirements)\r\n    * [Installation](#installation)\r\n        * [User Installation](#user-installation)\r\n        * [Developer Installation](#developer-installation)\r\n        * [Running the Tests](#running-the-tests)\r\n* [Usage](#usage)\r\n    * [Adding Events](#adding-events)\r\n    * [Adding Stations](#adding-stations)\r\n    * [Event and Station Filters](#event-and-station-filters)\r\n        * [Event Filters](#event-filters)\r\n        * [Station Filters](#station-filters)\r\n    * [Solver Specific Configuration](#solver-specific-configuration)\r\n* [Adding Support for a New Solver](#adding-support-for-a-new-solver)\r\n    * [Definition of the Required Parameters](#definition-of-the-required-parameters)\r\n    * [Definition of the Optional Parameters](#definition-of-the-optional-parameters)\r\n    * [The write() Function](#the-write-function)\r\n        * [The config Argument](#the-config-argument)\r\n        * [The events Argument](#the-events-argument)\r\n        * [The stations Argument](#the-stations-argument)\r\n\r\n## Dependencies and Installation\r\n\r\nThe module is written in pure Python and thus only has very minimal\r\ndependencies. It currently only works with Python 2.7.x as ObsPy does not yet\r\nsupport Python 3.x.\r\n\r\n### Requirements\r\n\r\n* Python 2.7.x\r\n* ObsPy >= 0.8.3\r\n\r\n#### Additional requirements for running the test suite:\r\n\r\n* pytest\r\n* flake8 >= 2.0\r\n* mock\r\n\r\n### Installation\r\n\r\n#### User Installation\r\n\r\nTo install the most recent version, make sure ObsPy is installed and execute\r\n\r\n```bash\r\n$ pip install https://github.com/krischer/wfs_input_generator/archive/master.zip\r\n```\r\n\r\nTo also install the requirements for the tests, run\r\n\r\n```bash\r\n$ pip install https://github.com/krischer/wfs_input_generator/archive/master.zip[tests]\r\n```\r\n\r\n#### Developer Installation\r\n\r\nIf you want to develop your own backends for writing input files for new\r\nsolvers you have to install the wfs_input_generator with an in-place\r\ninstallation.\r\n\r\n```bash\r\n$ git clone https://github.com/krischer/wfs_input_generator.git\r\n$ cd wfs_input_generator\r\n$ pip install -v -e .[tests]\r\n```\r\n\r\n#### Running the Tests\r\n\r\nThe simplest way to launch the tests is to use the `py.test` command in the\r\nmain `wfs_input_generator` directory. It will take care of discovering and\r\nexecuting all tests.\r\n\r\n```bash\r\n$ cd wfs_input_generator\r\n$ py.test\r\nTest session starts (darwin, 2.7.5)\r\n    ...\r\n```\r\n\r\nIf you intend on developing for this module, please write tests for your\r\nadditions and also guard against regressions by ensuring the existing test\r\nsuite passes.\r\n\r\n\r\n\r\n## Usage\r\n\r\nThe input file generation is steered with a Python script.\r\n\r\nThe first step it to create an `InputFileGenerator` object.\r\n\r\n```python\r\nfrom wfs_input_generator import InputFileGenerator\r\ngen = InputFileGenerator()\r\n```\r\n\r\nThis object requires seismic events, which act as the sources, seismic\r\nstations, which act as the receivers and finally some solver specific\r\nconfiguration to be able to eventually generate input files for different\r\nsolvers.\r\n\r\nThe events and stations can be the same for every solver, but the rest of the\r\nconfiguration cannot be unified; the different solvers simply require very\r\ndifferent parameters.\r\n\r\n\r\n### Adding Events\r\n\r\nEvents or seismic sources are added with the help of the `add_events()` method.\r\nDifferent formats are supported. The function can be called as often as\r\nnecessary to add as many events as desired. Duplicates will be automatically\r\ndiscarded.\r\n\r\nMany solvers are only able to accept a single event and thus will raise an\r\nerror upon input file creation if multiple events are present.\r\n\r\nDifferent ways to add one or more events are demonstrated by example:\r\n\r\n```python\r\n# Add one or more QuakeML files.\r\ngen.add_events(\"quake.xml\")\r\ngen.add_events([\"path/to/quake1.xml\", \"path/to/quake2.xml\"])\r\n\r\n# Add QuakeML with the URL to a webservice.\r\ngen.add_events(\"http://earthquakes.gov/quakeml?parameters=all\")\r\n\r\n# Directly add an event as a dictionary. Also a list of events.\r\ngen.add_events({\r\n    \"latitude\": 45.0,\r\n    \"longitude\": 12.1,\r\n    \"depth_in_km\": 13.0,\r\n    \"origin_time\":\r\n        obspy.UTCDateTime(2012, 4, 12, 7, 15, 48, 500000),\r\n    \"m_rr\": -2.11e+18,\r\n    \"m_tt\": -4.22e+19,\r\n    \"m_pp\": 4.43e+19,\r\n    \"m_rt\": -9.35e+18,\r\n    \"m_rp\": -8.38e+18,\r\n    \"m_tp\": -6.44e+18})\r\ngen.add_events([{...}, {...}, ...])\r\n\r\n# JSON also works. Either as a single JSON object or as an arrays of objects.\r\njson_str = \"\"\"\r\n{\r\n    \"latitude\": 45.0,\r\n    \"longitude\": 12.1,\r\n    \"depth_in_km\": 13.0,\r\n    \"origin_time\": \"2012-04-12T07:15:48.500000Z\",\r\n    \"m_rr\": -2.11e+18,\r\n    \"m_tt\": -4.22e+19,\r\n    \"m_pp\": 4.43e+19,\r\n    \"m_rt\": -9.35e+18,\r\n    \"m_rp\": -8.38e+18,\r\n    \"m_tp\": -6.44e+18\r\n}\r\n\"\"\"\r\ngen.add_events(json_str)\r\n\r\njson_str = \"\"\"\r\n[{...}, {...}]]\r\n\"\"\"\r\ngen.add_events(json_str)\r\n```\r\n\r\n\r\n### Adding Stations\r\n\r\nThe stations will act as the receivers during the simulation. Again, the most\r\ncommon formats are supported to facilitate integration into existing workflows.\r\n\r\n```python\r\n# Add one or more (X)SEED files.\r\ngen.add_stations(\"station1.seed\")\r\ngen.add_stations([\"station2.seed\", \"station3_xseed.xml\"])\r\n\r\n# StationXML works just fine.\r\ngen.add_stations(\"station4.xml\")\r\ngen.add_stations([\"station5.ml\", \"station6.xml\"])\r\n\r\n# Webservices serving StationXML or (X)SEED work by\r\n# simply providing the URL.\r\ngen.add_stations(\"http://fdsn_webservice.org/...\")\r\n\r\n# There is also legacy support for coordinates\r\n# embedded into SAC files.\r\ngen.add_stations(\"station7.sac\")\r\ngen.add_stations([\"station8.sac\", \"station9.sac\"])\r\n\r\n# Furthermore Python dictionaries are fine. The id is\r\n# a simple string but for many purposes it should be\r\n# NETWORK_ID.STATION_ID as defined in the SEED manual.\r\ngen.add_stations({\r\n    \"id\": \"BW.FURT\",\r\n    \"latitude\": 48.162899,\r\n    \"longitude\": 11.2752,\r\n    \"elevation_in_m\": 565.0,\r\n    \"local_depth_in_m\": 10.0})\r\ngen.add_stations([{...}, {...}, ...])\r\n\r\n# JSON objects and arrays of objects.\r\njson_str = \"\"\"\r\n{\r\n    \"id\": \"BW.FURT\",\r\n    \"latitude\": 48.162899,\r\n    \"longitude\": 11.2752,\r\n    \"elevation_in_m\": 565.0,\r\n    \"local_depth_in_m\": 10.0})\r\n}\r\n\"\"\"\r\ngen.add_stations(json_str)\r\n\r\njson_str = \"\"\"\r\n[{...}, {...}, ...]\r\n\"\"\"\r\ngen.add_stations(json_str)\r\n```\r\n\r\n### Event and Station Filters\r\n\r\nEvents and stations can be filtered. This is useful for using the same\r\n(potentially very large) StationXML and QuakeML files for many simulations.\r\nSimply provide a different filter for each run restricting the existing\r\ndataset.\r\n\r\nFilters are defined as positive filters, thus they describe what should be the\r\ncontent of the input files and not what should be neglected.\r\n\r\nYou can set and change the filters at any time during the setup process. They\r\nare applied at input file creation time.\r\n\r\n#### Event Filters\r\n\r\nEvent filters are only useful for QuakeML input as they depend on the public id\r\nof an event. They are simply a list of one ore more event ids. Note that any\r\nevent not having an event id will be discarded as soon as a filter is present.\r\n\r\n```python\r\ngen.event_filter = [\"smi:local/event_id_1\", \"smi:/local_event_id_2\"]\r\n\r\n# A JSON array also works.\r\ngen.event_filter = '[\"smi:local/event_id_1\", \"smi:/local_event_id_2\"]'\r\n```\r\n\r\n\r\n#### Station Filters\r\n\r\nStation filters are a list of station ids. UNIX style wildcards are supported.\r\n\r\n```python\r\ngen.station_filter = [\"BW.FURT\", \"TA.A*\", \"TA.Y?H\"]\r\n\r\n# Again JSON arrays are just as fine.\r\ngen.station_filter = '[\"BW.FURT\", \"TA.A*\", \"TA.Y?H\"]'\r\n```\r\n\r\n### Solver Specific Configuration\r\n\r\nThe rest of the configuration is unfortunately very solver dependent. The\r\ninputs they require are just too different to make it feasible to extract a\r\ncommon subset.\r\n\r\nIf needed the supported output formats of the module can be queried:\r\n\r\n```python\r\n>>> gen.get_available_formats()\r\n['ses3d_4_0', 'SPECFEM3D_CARTESIAN']\r\n```\r\n\r\nIt is also possible to request the parameters needed for a specific solver. The\r\n`get_config_params()` method returns two dictionaries. The first one describes\r\nthe required parameters; the keys are the parameter names and the values a\r\ntwo-tuple of type and description. The second one describes the optional\r\nparameters. The keys are once again the parameters names, the values this time\r\na three-tuple of default value, type, and description.\r\n\r\n```python\r\n>>> required, optional = gen.get_config_params('ses3d_4_0')\r\n>>> required.items()[0]\r\n('mesh_max_longitude', (float, 'The maximum longitude of the mesh'))\r\n>>> optional.items()[0]\r\n('adjoint_forward_sampling_rate', (15, int, 'The sampling...')\r\n```\r\n\r\nOnce the necessary parameters are known they can be set in a couple of\r\ndifferent ways. The required parameters must be set before a file can be\r\nwritten, otherwise an error will be raised. If no value is given for an\r\noptional parameter, its default value will be used. Automatic type conversion\r\nwill be performed by the `write()` method. If it fails an error will be\r\nraised.\r\n\r\n```python\r\n# Directly attach attributes to the config object.\r\ngen.config.time_stepping = 5.5\r\n\r\n# Set values from a dictionary.\r\ngen.add_configuration({'some_value': 2,\r\n                       'other_value': 2})\r\n\r\n# From a JSON string.\r\ngen.add_configuration('{\"some_value\":2, ...}')\r\n```\r\n\r\nThe last step is to actually write the input files. Per default it will return\r\na dictionary with the keys being the filenames and the values being the file\r\ncontents.\r\n\r\n```python\r\n>>> output = gen.write(format=\"ses3d_4_0\")\r\n>>> output.keys()\r\n['stf', 'relax', 'setup', 'event_list', 'event_1', 'recfile_1']\r\n\r\n# One can also directly write the files to a specified folder.\r\ngen.write(format=\"ses3d_4_0\", output_dir=\"solver_input_files\")\r\n```\r\n\r\n\r\n\r\n## Adding Support for a new Solver\r\n\r\nAdding support for a new solver (also called a backend) is simply a matter of\r\nadding a new Python script. The input file generator main class will take care\r\nof discovering and using it.\r\n\r\nAll backends have to be stored in the `wfs_input_generator/backends`\r\nsubdirectory. It has to have the name `write_SOLVER.py` where `SOLVER` should\r\nbe an accurate description of the used solver.\r\n\r\nThe best way to add a new solver is to use\r\n[an existing one](https://github.com/krischer/wfs_input_generator/blob/master/wfs_input_generator/backends/write_ses3d_4_0.py)\r\nas a template.\r\n\r\nThe file has to contain three things, the definition of the required\r\nparameters, the definition of the optional parameters, and a `write()`\r\nfunction.\r\n\r\nThe wfs_input_generator module will take care that all required parameters will\r\nbe present and that all parameters have the correct type.\r\n\r\n### Definition of the Required Parameters\r\n\r\nThe required parameters are specified in the file in a variable called\r\n`REQUIRED_CONFIGURATION`. It is a dictionary with the keys being the parameter\r\nnames and the values a two-tuple of type and description.\r\n\r\n```python\r\nREQUIRED_CONFIGURATION = {\r\n    \"some_parameter\": (str, \"This does something\"),\r\n    \"another_parameters\": (float, \"This does something else),\r\n    \"one_more\": (lambda x: map(float, x), \"This will always be a list of floats\")\r\n}\r\n```\r\n\r\n### Definition of the Optional Parameters\r\n\r\nThe optional parameters are specified in the file in a variable called\r\n`DEFAULT_CONFIGURATION`. It is another dictionary. The keys are once again the\r\nparameters names, the values this time a three-tuple of default value, type,\r\nand description.\r\n\r\n```python\r\nDEFAULT_CONFIGURATION = {\r\n    \"some_required_parameter\": (\"default\", str, \"A parameter\"),\r\n    ...\r\n}\r\n```\r\n\r\n### The write() Function\r\n\r\nThe `write()` function will be called to assemble the input files. This is the\r\nactual job of any backend.\r\n\r\nThe file has to have a call signature akin to\r\n\r\n```python\r\ndef write(config, events, stations):\r\n    # Logic here\r\n    ...\r\n\r\n    return {\r\n        \"filename_1\": content_1,\r\n        \"filename_2\": content_2\r\n    }\r\n```\r\n\r\nand return a dictionary with the keys being the names of the files to be\r\ngenerated and the values being the actual contents. Unicode should work just\r\nfine.\r\n\r\nAt any point you can be sure that the contents of the three arguments are fine.\r\nYou do not need to perform any type checking or test for missing parameters.\r\nThe module takes care that the parameters are sanitized.\r\n\r\nWhat you need to do is check things that cannot be caught by the parameter\r\nspecification or something else, e.g. raise an error if more than one event is\r\npresent but the solver can only deal with one event at a time and similar\r\nthings.\r\n\r\n#### The config Argument\r\n\r\nThe config argument is a `obspy.core.AttribDict` instance and will contain all\r\nthe values specified in `REQUIRED_CONFIGURATION` and `DEFAULT_CONFIGURATION`.\r\nAll parameters will be present; the `wfs_input_generator` module assures that\r\nthe user specified all required parameters. Also all optional parameters will\r\nbe present; values that the user did not specify will be replaced by the\r\ndefault values.\r\n\r\n#### The events Argument\r\n\r\nIt is a list of dictionaries. You can be sure they have the following format:\r\n\r\n```python\r\n{\"latitude\": 28.7,\r\n \"longitude\": -113.1,\r\n \"depth_in_km\": 13.0,\r\n \"origin_time\": obspy.UTCDateTime(2012, 4, 12, 7, 15, 48, 500000),\r\n \"m_rr\": -2.11e+18,\r\n \"m_tt\": -4.22e+19,\r\n \"m_pp\": 4.43e+19,\r\n \"m_rt\": -9.35e+18,\r\n \"m_rp\": -8.38e+18,\r\n \"m_tp\": -6.44e+18}\r\n```\r\n\r\nThe `origin_time` value will be an `obspy.UTCDateTime` instance, the rest\r\nordinary floats. Again no need to check for any missing parameters. They will\r\nall be present and have the correct type.\r\n\r\n#### The stations Argument\r\nIt is a list of dictionaries. You can be sure they have the following format:\r\n\r\n```python\r\n{\"id\": \"BW.FURT\",\r\n \"latitude\": 48.162899,\r\n \"longitude\": 11.2752,\r\n \"elevation_in_m\": 565.0,\r\n \"local_depth_in_m\": 0.0},\r\n```\r\n\r\nThe `id` value will be a string and all other values will be floats.\r\n","google":"UA-44800463-1","note":"Don't delete this file! It's used internally to help with page regeneration."}